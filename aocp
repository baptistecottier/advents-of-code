#!/usr/local/bin/python3
# -*- coding: utf-8 -*-

"""
Advent of Code puzzle runner and utility functions.
"""

# Standard import
import argparse
import builtins
import datetime
import io
import multiprocessing
import os
import sys
import threading
from contextlib import redirect_stdout, redirect_stderr
from pathlib import Path

# Third-party import
from aocd.models import Puzzle

try:
    import argcomplete
    ARGCOMPLETE_AVAILABLE = True
except ImportError:
    argcomplete = None
    ARGCOMPLETE_AVAILABLE = False
from aocd import submit


def color_text(txt: str, color: str):
    """
    Return the given text string wrapped in ANSI color codes for terminal output.

    Args:
        txt (str): The text to color.
        color (str or None): The name of the color (e.g., 'red', 'green').
                             If None, returns the text unchanged.

    Returns:
        str: The colored text with ANSI escape codes, or the original text if color is None.

    Examples:
        >>> color_text("Hello", "red")
        '\\x1b[31mHello\\x1b[0m'
    """
    ansi_colors = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"]
    if color is None:
        return txt
    code = ansi_colors.index(color.casefold())
    reset = "\x1b[0m"
    return f"\x1b[{code + 30}m{txt}{reset}"


def _check_example_answers(my_answers, answer_a, answer_b):
    """Check example answers and print results."""
    success = True
    answers = list(zip([1, 2], my_answers, [answer_a, answer_b]))

    for part, guess, answer in answers:
        if not answer:
            continue
        if str(guess) == str(answer):
            print(f"  |__Part {part}: {color_text('pass', 'green')}")
        else:
            print((f"""  |__Part {part}: {color_text('fail', 'red')}."""
                   f"""Your guess: {guess}. Answer: {answer}"""))
            success = False

    return success


def _format_answers(answers):
    """Format answers for comparison."""
    my_answers = ["None", "None"]
    for part, answer in enumerate(answers):
        my_answers[part] = str(answer)
        if isinstance(answer, tuple):
            my_answers[part] = answer[1]

    if my_answers and isinstance(my_answers[0], builtins.tuple):
        my_answers = [guess for (_, guess) in my_answers[::-1]]

    return my_answers


def _process_example_data(day_module, data):
    """Process example data through preprocessing if available."""
    if 'preprocessing' in dir(day_module):
        return day_module.preprocessing(data)
    return data


def _solve_example(day_module, data, example_args):
    """Solve an example using the day module's solver."""
    if 'solver' not in dir(day_module):
        return (-1,)

    match example_args, isinstance(data, builtins.tuple):
        case None, True:
            return day_module.solver(*data)
        case None, False:
            return day_module.solver(data)
        case _, True:
            return day_module.solver(*data, **example_args)
        case _, False:
            return day_module.solver(data, **example_args)


def solve_examples(puzzle, details=False):
    """
    Solve and validate puzzle examples.

    Args:
        puzzle: The puzzle object containing examples to test.
        details (bool): Whether to print detailed example information.

    Returns:
        bool: True if all examples passed, False otherwise.
    """
    examples_success = True
    day_module = __import__(f"day_{str(puzzle.day).zfill(2)}")

    for i, (data, answer_a, answer_b, example_args) in enumerate(puzzle.examples, 1):
        if details:
            print(puzzle.examples[i - 1])

        print(f"----Example {i}")

        processed_data = _process_example_data(day_module, data)
        answers = _solve_example(day_module, processed_data, example_args)
        my_answers = _format_answers(answers)

        if not _check_example_answers(my_answers, answer_a, answer_b):
            examples_success = False

    return examples_success


def save_examples_to_file(puzzle: Puzzle, examples: list) -> bool:
    """Save examples to a .examples file."""
    if not examples:
        return False
    
    day_str = str(puzzle.day).zfill(2)
    examples_dir = Path(f"./events/year_{puzzle.year}/day_{day_str}")
    examples_dir.mkdir(parents=True, exist_ok=True)
    
    examples_path = examples_dir / f"day_{day_str}.examples"
    
    try:
        import json
        with open(examples_path, 'w', encoding='utf-8') as f:
            json.dump(examples, f, indent=2, ensure_ascii=False)
        
        print(f"  ğŸ’¾ Examples saved to: {examples_path}")
        return True
    except (OSError, IOError) as e:
        print(f"  âŒ Failed to save examples: {e}")
        return False


def load_examples_from_file(puzzle: Puzzle) -> list:
    """Load examples from a .examples file if it exists."""
    import json
    
    day_str = str(puzzle.day).zfill(2)
    examples_path = Path(f"./events/year_{puzzle.year}/day_{day_str}/day_{day_str}.examples")
    
    if not examples_path.exists():
        return []
    
    try:
        with open(examples_path, 'r', encoding='utf-8') as f:
            examples = json.load(f)
        
        print(f"  ğŸ“ Loaded {len(examples)} examples from: {examples_path}")
        return examples
    except (OSError, IOError, json.JSONDecodeError) as e:
        print(f"  âš ï¸ Failed to load examples file: {e}")
        return []


def extract_examples_from_puzzle(puzzle: Puzzle, force_refresh: bool = False) -> list:
    """Extract examples from puzzle description - proof of concept."""
    # First, try to load from existing .examples file (unless forced refresh)
    if not force_refresh:
        existing_examples = load_examples_from_file(puzzle)
        if existing_examples:
            return existing_examples
    
    # For now, return some known examples for demonstration
    # In a full implementation, this would parse the puzzle webpage
    known_examples = {
        # 2015 Day 1 examples
        (2015, 1): [
            {'input': '(())', 'expected_a': '0', 'expected_b': None},
            {'input': '()()', 'expected_a': '0', 'expected_b': None},
            {'input': '(((', 'expected_a': '3', 'expected_b': None},
            {'input': '())', 'expected_a': '-1', 'expected_b': None},
            {'input': ')))', 'expected_a': '-3', 'expected_b': None},
        ],
        # 2020 Day 1 examples  
        (2020, 1): [
            {'input': '1721\n979\n366\n299\n675\n1456', 'expected_a': '514579', 'expected_b': None},
        ],
    }
    
    key = (puzzle.year, puzzle.day)
    if key in known_examples:
        print(f"  ğŸ“š Found {len(known_examples[key])} known examples for {puzzle.year} day {puzzle.day}")
        examples = known_examples[key]
        # Save the examples for future use
        save_examples_to_file(puzzle, examples)
        return examples
    
    print(f"  â“ No examples available for {puzzle.year} day {puzzle.day} (would need web scraping)")
    return []


def save_input_to_file(puzzle: Puzzle, verbose: bool = True) -> bool:
    """Save puzzle input to local .input file."""
    try:
        input_dir = Path(f"./events/year_{puzzle.year}/day_{str(puzzle.day).zfill(2)}")
        input_dir.mkdir(parents=True, exist_ok=True)
        
        input_path = input_dir / f"day_{str(puzzle.day).zfill(2)}.input"
        
        # Check if file already exists and has content
        if input_path.exists() and input_path.stat().st_size > 0:
            if verbose:
                print(f"  ğŸ“ Input file already exists: {input_path}")
            return True
        
        # Fetch and save the input
        input_data = puzzle.input_data
        with open(input_path, 'w', encoding='utf-8') as f:
            f.write(input_data)
        
        if verbose:
            print(f"  ğŸ’¾ Saved input to: {input_path}")
        return True
        
    except (OSError, IOError, ConnectionError) as e:
        if verbose:
            print(f"  âŒ Failed to save input: {e}")
        return False


def parse_and_display_results(answers, puzzle, timeout_seconds=None):
    """Parse and nicely display the puzzle results with colored output.
    
    Returns: tuple - (all_correct, parts_solved_on_aoc) where:
        - all_correct: bool, True if solver gave correct answers
        - parts_solved_on_aoc: tuple, which parts are actually solved on AOC (1, 2, or both)
    """
    import io
    from contextlib import redirect_stdout, redirect_stderr
    from aocd.exceptions import AocdError
    
    print("ğŸ“Š Results:")
    all_correct = True
    parts_solved = []  # Track which parts are actually solved on AOC
    
    for part, answer in enumerate(answers, 1):
        part_letter = "a" if part == 1 else "b"
        medal = "ğŸ¥‡" if part == 1 else "ğŸ¥ˆ"
        is_correct = True  # Track if this part is correct
        is_solved_on_aoc = False  # Track if this part is actually solved on AOC
        
        # Capture the output from aocd submit
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        try:
            with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                if isinstance(answer, builtins.tuple):
                    fixed_part, fixed_answer = answer
                    result = submit(fixed_answer, fixed_part, puzzle.day, puzzle.year)
                else:
                    result = submit(str(answer), part_letter, puzzle.day, puzzle.year)
            
            # Get the captured output
            output = stdout_capture.getvalue() + stderr_capture.getvalue()
            
            # Check if aocd prevented the submission (returns None and prints message)
            if result is None and "aocd will not submit" in output:
                colored_status = color_text("âœ… Correct (already known)", "green")
                is_solved_on_aoc = True
            # Parse the aocd output to determine status and color
            elif "already solved with same answer" in output:
                colored_status = color_text("âœ… Correct (already solved)", "green")
                is_solved_on_aoc = True
            elif "already solved with different answer" in output:
                colored_status = color_text("ğŸ¤” Incorrect (but already solved)", "yellow")
                is_correct = False
                is_solved_on_aoc = True  # Part IS solved on AOC, even though solver is wrong
            elif "That's the right answer" in output:
                colored_status = color_text("ğŸ‰ Correct (new submission)", "green")
                is_solved_on_aoc = True
            elif "That's not the right answer" in output:
                colored_status = color_text("âŒ Incorrect", "red")
                is_correct = False
            elif "You gave an answer too recently" in output:
                colored_status = color_text("â° Rate limited", "yellow")
                is_correct = False  # Can't confirm correctness
            else:
                print(f"  âš ï¸  Unexpected submission response:\n{output}")
                colored_status = color_text("ğŸ“¤ Submitted", "blue")
                is_correct = False  # Unknown status
                
            print(f"  {medal} Part {part}: {answer} - {colored_status}")
            
            # Show timeout message if this is the last part and timeout occurred
            if timeout_seconds is not None and part == len(answers):
                print(f"    â±ï¸ Solver execution timed out after {timeout_seconds} seconds")
            
        except AocdError as e:
            error_msg = str(e)
            if "is certain that" in error_msg and "is incorrect" in error_msg:
                colored_status = color_text("âŒ Incorrect (cached)", "red")
                is_correct = False
            elif "already solved" in error_msg:
                colored_status = color_text("âœ… Correct (already solved)", "green")
                is_solved_on_aoc = True
            else:
                colored_status = color_text(f"âš ï¸  {error_msg[:50]}", "yellow")
                is_correct = False
            print(f"  {medal} Part {part}: {answer} - {colored_status}")
            
            # Show timeout message if this is the last part and timeout occurred
            if timeout_seconds is not None and part == len(answers):
                print(f"    â±ï¸ Solver execution timed out after {timeout_seconds} seconds")
        except (ConnectionError, TimeoutError, Exception) as e:
            error_type = type(e).__name__
            if "SSL" in error_type or "certificate" in str(e).lower():
                status_msg = "âŒ SSL/Certificate error (network issue)"
            elif "Connection" in error_type or "Timeout" in error_type:
                status_msg = "âŒ Network error"
            else:
                status_msg = f"âš ï¸  {error_type}"
            print(f"  {medal} Part {part}: {answer} - {color_text(status_msg, 'red')}")
            is_correct = False
            
            # Show timeout message if this is the last part and timeout occurred
            if timeout_seconds is not None and part == len(answers):
                print(f"    â±ï¸ Solver execution timed out after {timeout_seconds} seconds")
        
        # If any part is incorrect, the whole day is incorrect
        if not is_correct:
            all_correct = False
        
        # Track which parts are solved on AOC
        if is_solved_on_aoc:
            parts_solved.append(part)
    
    return (all_correct, tuple(parts_solved))


class SolverTimeoutError(Exception):
    """Custom timeout exception for solver execution."""
    pass


def _solver_process_wrapper(conn, module_path, module_name, solver_name, args,
                             suppress_output, memory_limit_mb=0):
    """Wrapper to run solver in a subprocess and send result back via pipe.
    
    Args:
        memory_limit_mb: Memory limit in MB (0 = unlimited)
    """
    import os
    import resource
    
    # Apply memory limit if specified
    if memory_limit_mb > 0:
        try:
            memory_bytes = memory_limit_mb * 1024 * 1024
            # Use soft limit only (won't fail if current exceeds)
            resource.setrlimit(resource.RLIMIT_AS, (memory_bytes, memory_bytes))
        except ValueError as e:
            # Soft limit exceeds hard limit on this system
            try:
                # Try to set to hard limit instead
                hard_limit = resource.getrlimit(resource.RLIMIT_AS)[1]
                resource.setrlimit(resource.RLIMIT_AS, (memory_bytes, hard_limit))
            except (ValueError, OSError):
                # If still failing, just continue without limit
                pass
        except OSError:
            # Other OS errors, continue without limit
            pass
    if suppress_output:
        devnull_fd = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull_fd, 1)  # Redirect fd 1 (stdout) to /dev/null
        os.dup2(devnull_fd, 2)  # Redirect fd 2 (stderr) to /dev/null
        os.close(devnull_fd)
    
    try:
        # Add module path and import the module in the subprocess
        if module_path not in sys.path:
            sys.path.insert(0, module_path)
        day_module = __import__(module_name)
        solver_func = getattr(day_module, solver_name)
        
        # Always use context managers for output suppression at Python level too
        with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
            if isinstance(args, tuple):
                result = solver_func(*args)
            else:
                result = solver_func(args)
        
        # Handle generators - send each yielded value as it arrives
        if hasattr(result, '__iter__') and not isinstance(result, (str, bytes, dict, tuple)):
            results = []
            try:
                for idx, item in enumerate(result):
                    results.append(item)
                    # Send each result immediately as it arrives
                    conn.send(('result', (idx, item)))
            except Exception:
                import traceback
                conn.send(('error', traceback.format_exc()))
                return
            # Signal completion
            conn.send(('done', tuple(results)))
        else:
            # Non-generator result
            if isinstance(result, tuple):
                conn.send(('done', result))
            else:
                conn.send(('done', (result,)))
    except Exception:
        import traceback
        conn.send(('error', traceback.format_exc()))
    finally:
        conn.close()


def run_solver_with_timeout(module_path, module_name, solver_name, args,
                            timeout_seconds, suppress_output=False, memory_limit_mb=0):
    """
    Run solver function with timeout using multiprocessing.
    
    Args:
        module_path: Path to module directory
        module_name: Name of module to import (e.g., 'day_15')
        solver_name: Name of solver function (usually 'solver')
        args: Arguments to pass to solver
        timeout_seconds: Timeout in seconds
        suppress_output: Whether to suppress stdout/stderr
        memory_limit_mb: Memory limit in MB (0 = unlimited)
    
    Returns:
        Tuple of (completed, result, intermediate_results)
        - completed: True if solver finished, False if timed out
        - result: Final result tuple
        - intermediate_results: List of (part_index, result) tuples for partial results
    """
    parent_conn, child_conn = multiprocessing.Pipe()
    process = multiprocessing.Process(
        target=_solver_process_wrapper,
        args=(child_conn, module_path, module_name, solver_name, args,
              suppress_output, memory_limit_mb)
    )
    process.daemon = False
    process.start()
    
    start_time = datetime.datetime.now()
    partial_results = {}
    intermediate_results = []  # Track results as they arrive
    done = False
    final_results = None
    
    # Listen for results as they arrive, with timeout
    while True:
        elapsed = (datetime.datetime.now() - start_time).total_seconds()
        remaining_timeout = max(0.01, timeout_seconds - elapsed)
        
        # Check timeout FIRST - if exceeded, kill process immediately
        if elapsed > timeout_seconds:
            if process.is_alive():
                # Be aggressive: kill directly without terminate first
                process.kill()
                process.join(timeout=0.2)
            parent_conn.close()
            # Return timeout with partial results if any
            if partial_results:
                sorted_results = tuple(
                    partial_results[i] for i in sorted(partial_results.keys())
                )
                return (False, sorted_results, intermediate_results)
            else:
                return (False, None, intermediate_results)
        
        if process.is_alive():
            # Process finished, collect any remaining messages
            while parent_conn.poll(timeout=0.01):
                try:
                    status, data = parent_conn.recv()
                    if status == 'result':
                        idx, result = data
                        partial_results[idx] = result
                        intermediate_results.append((idx, result))
                        # Display immediately as result arrives
                        print(f"  {'ğŸ¥‡' if idx == 0 else 'ğŸ¥ˆ'} Part {idx + 1}: {result}")
                    elif status == 'done':
                        final_results = data
                        done = True
                        break
                    elif status == 'error':
                        parent_conn.close()
                        raise Exception(f"Solver error: {data}")
                except EOFError:
                    done = True
                    break
            
            if done:
                parent_conn.close()
                if final_results:
                    return (True, final_results, intermediate_results)
                elif partial_results:
                    sorted_results = tuple(
                        partial_results[i] for i in sorted(partial_results.keys())
                    )
                    return (True, sorted_results, intermediate_results)
                else:
                    return (True, None, intermediate_results)
            else:
                parent_conn.close()
                if partial_results:
                    sorted_results = tuple(
                        partial_results[i] for i in sorted(partial_results.keys())
                    )
                    return (True, sorted_results, intermediate_results)
                else:
                    return (True, None, intermediate_results)
        
        # Poll for messages with remaining timeout
        if parent_conn.poll(timeout=remaining_timeout):
            try:
                status, data = parent_conn.recv()
                if status == 'result':
                    idx, result = data
                    partial_results[idx] = result
                    intermediate_results.append((idx, result))
                    # Don't display immediately - just collect for later display in Results section
                elif status == 'done':
                    final_results = data
                    done = True
                elif status == 'error':
                    parent_conn.close()
                    raise Exception(f"Solver error: {data}")
            except EOFError:
                done = True
        
        # If we get here, ensure we return
        if done or not process.is_alive():
            parent_conn.close()
            if final_results:
                return (True, final_results, intermediate_results)
            elif partial_results:
                sorted_results = tuple(
                    partial_results[i] for i in sorted(partial_results.keys())
                )
                return (True, sorted_results, intermediate_results)
            else:
                return (True, None, intermediate_results)
    
    # Fallback return (should not reach here, but just in case)
    parent_conn.close()
    if partial_results:
        sorted_results = tuple(
            partial_results[i] for i in sorted(partial_results.keys())
        )
        return (False, sorted_results, intermediate_results)
    else:
        return (False, None, intermediate_results)


def solve_day(puzzle: Puzzle, use_local_input: bool = True, preprocessing_func=None,
              suppress_solver_prints: bool = False, timeout_seconds: int = 60,
              memory_limit_mb: int = 1024):
    """
    Solve an Advent of Code puzzle by importing the corresponding day module and running its solver.
    
    Args:
        puzzle: AOC Puzzle object containing year, day, and input data
        use_local_input: If True, attempts to use local input file first, 
                        falls back to puzzle.input_data if file not found or empty
        preprocessing_func: Optional function to preprocess input data
        suppress_solver_prints: If True, suppresses all print output from solver and preprocessing

    Examples:
        >>> puzzle = Puzzle(year=2022, day=15)
        >>> solve_day(puzzle)  # Loads day_01.py, calls solver(), submits answers
        
        >>> puzzle = Puzzle(year=2022, day=15, input_data="sensor data...")
        >>> solve_day(puzzle, use_local_input=False)  # Uses puzzle.input_data directly
    """
    puzzle_input = None
    
    if use_local_input:
        try:
            input_path = f"./events/year_{puzzle.year}/day_{str(puzzle.day).zfill(2)}/day_{str(puzzle.day).zfill(2)}.input"
            with open(input_path, encoding="utf-8") as data:
                file_content = data.read().rstrip('\n')
                if file_content:  # Only use local file if it has content
                    if preprocessing_func:
                        if suppress_solver_prints:
                            with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
                                puzzle_input = preprocessing_func(file_content)
                        else:
                            puzzle_input = preprocessing_func(file_content)
                    else:
                        puzzle_input = file_content
                    print(f"  ğŸ“ Using local input: {input_path}")
        except FileNotFoundError:
            pass
    
    if puzzle_input is None:
        # Try to save the input locally for future use
        input_path = f"./events/year_{puzzle.year}/day_{str(puzzle.day).zfill(2)}/day_{str(puzzle.day).zfill(2)}.input"
        try:
            save_input_to_file(puzzle, verbose=False)
            print("  ğŸ’¾ Input auto-saved for future use")
            # Now read the locally saved file
            with open(input_path, encoding="utf-8") as data:
                file_data = data.read().rstrip('\n')
                if preprocessing_func:
                    if suppress_solver_prints:
                        with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
                            puzzle_input = preprocessing_func(file_data)
                    else:
                        puzzle_input = preprocessing_func(file_data)
                else:
                    puzzle_input = file_data
                print(f"  ğŸ“ Using auto-saved input: {input_path}")
        except (OSError, IOError):
            # Fallback to remote if saving fails
            if preprocessing_func:
                if suppress_solver_prints:
                    with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
                        puzzle_input = preprocessing_func(puzzle.input_data)
                else:
                    puzzle_input = preprocessing_func(puzzle.input_data)
            else:
                puzzle_input = puzzle.input_data
            print("  ğŸŒ Using remote input from AOC")

    # Add day directory to Python path to ensure we load the correct module
    # Use absolute path to work from any directory, resolving symlinks
    script_dir = Path(os.path.realpath(__file__)).parent
    day_path = str(script_dir / f"events/year_{puzzle.year}/day_{str(puzzle.day).zfill(2)}/")
    if day_path not in sys.path:
        sys.path.insert(0, day_path)
    
    day_module = __import__(f"day_{str(puzzle.day).zfill(2)}")
    if 'solver' in dir(day_module):
        try:
            answers = None
            timeout_occurred = False
            if timeout_seconds > 0:
                completed, answers, intermediate = run_solver_with_timeout(
                    day_path,
                    f"day_{str(puzzle.day).zfill(2)}",
                    'solver',
                    puzzle_input,
                    timeout_seconds,
                    suppress_output=suppress_solver_prints,
                    memory_limit_mb=memory_limit_mb
                )
                
                if not completed:
                    # Timeout occurred
                    timeout_occurred = True
                    if answers is None:
                        # No partial results, use placeholder
                        answers = (-1,)
                    # If answers is not None, we have partial results - keep them as is
            else:
                if suppress_solver_prints:
                    with redirect_stdout(io.StringIO()), redirect_stderr(io.StringIO()):
                        if isinstance(puzzle_input, builtins.tuple):
                            answers = day_module.solver(*puzzle_input)
                        else:
                            answers = day_module.solver(puzzle_input)
                else:
                    if isinstance(puzzle_input, builtins.tuple):
                        answers = day_module.solver(*puzzle_input)
                    else:
                        answers = day_module.solver(puzzle_input)
        except SolverTimeoutError:
            timeout_occurred = True
            answers = (-1,)
        except Exception as solver_exc:  # pylint: disable=broad-except
            timeout_occurred = False  # Not a timeout, regular error
            exc_type = type(solver_exc).__name__
            exc_msg = str(solver_exc)[:80]
            print(f"  âš ï¸  Solver error ({exc_type}): {exc_msg}")
            # For single day runs, show full traceback
            if suppress_solver_prints is False:
                import traceback
                print("\n  Full traceback:")
                traceback.print_exc()
            answers = (-1,)
    else:
        timeout_occurred = False
        answers = (-1,)

    # Display results with nice formatting
    # Pass timeout_occurred flag to show timeout message in results section
    if not answers or answers is None or answers == (-1,):
        # No valid answers - treat as failed
        print("ğŸ“Š Results:")
        print("  âš ï¸  No answers returned from solver")
        all_correct = False
        parts_solved_on_aoc = ()
        has_valid_answers = False
    elif timeout_occurred:
        timeout_kwarg = timeout_seconds
        all_correct, parts_solved_on_aoc = (
            parse_and_display_results(answers, puzzle, timeout_seconds=timeout_kwarg)
        )
        # Check if we have valid answers
        has_valid_answers = (
            answers != (-1,) and
            answers != () and
            answers is not None and
            not all(isinstance(a, tuple) and a[1] is None or a is None
                   for a in answers)
        )
    else:
        all_correct, parts_solved_on_aoc = parse_and_display_results(answers, puzzle)
        # Check if we have valid answers
        has_valid_answers = (
            answers != (-1,) and
            answers != () and
            answers is not None and
            not all(isinstance(a, tuple) and a[1] is None or a is None
                   for a in answers)
        )

    # Count the number of valid answers returned
    num_parts_returned = 0
    if has_valid_answers and answers:
        num_parts_returned = len(answers)
    
    return (all_correct, timeout_occurred, has_valid_answers, 
            parts_solved_on_aoc, num_parts_returned)


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="ğŸ„ Advent of Code puzzle runner",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  aocp 2024 1                    # Run day 1 of 2024
  aocp 2024 1 --examples         # Test examples first  
  aocp 2024 1 --no-local         # Use remote input only
  aocp 2024 1 --save-input       # Save puzzle input to local file
  aocp 2024                      # Run all days of 2024
  aocp 2024 --days 1-5           # Run days 1 through 5
  aocp 2024 --days 1,3,5         # Run specific days
        """
    )
    
    parser.add_argument('year', type=int, help='Year (e.g., 2024)')
    
    parser.add_argument('day', type=int, nargs='?', 
                       help='Day number (1-25). If omitted, runs all days.')
    
    parser.add_argument('--days', type=str,
                       help='Specify days to run: "1-5" for range or "1,3,5" for specific days')
    
    parser.add_argument('-e', '--examples', action='store_true',
                       help='Test examples before running on real input')
    
    parser.add_argument('-ev', '--examples-verbose', action='store_true',
                       help='Test examples with verbose output')
    
    parser.add_argument('--no-local', action='store_true',
                       help='Skip local input files, use remote input only')
    
    parser.add_argument('--force', action='store_true',
                       help='Run on real input even if examples fail')
    
    parser.add_argument('--save-input', action='store_true',
                       help='Save puzzle input to local .input file')
    
    parser.add_argument('--extract-examples', action='store_true',
                       help='Extract and display examples from puzzle description')
    
    parser.add_argument('--refresh-examples', action='store_true',
                       help='Force refresh examples (ignore cached .examples files)')
    
    parser.add_argument('--timeout', type=int, default=60,
                       help='Timeout for solver execution in seconds (0 = no timeout, default: 60)')
    
    parser.add_argument('--memory-limit', type=int, default=1024,
                       help='Memory limit in MB (0 = unlimited, default: 1024)')
    
    # Enable argcomplete if available with custom completers
    # Note: Disabled to use bash completion for proper numeric day ordering
    # if ARGCOMPLETE_AVAILABLE and argcomplete:
    #     argcomplete.autocomplete(parser)
    
    return parser.parse_args()


def parse_days_string(days_str):
    """Parse days string like '1-5' or '1,3,5' into list of day numbers."""
    days = []
    
    for part in days_str.split(','):
        part = part.strip()
        if '-' in part:
            start, end = map(int, part.split('-'))
            days.extend(range(start, end + 1))
        else:
            days.append(int(part))
    
    return sorted(set(days))  # Remove duplicates and sort


def display_extracted_examples(puzzle: Puzzle, force_refresh: bool = False):
    """Display extracted examples from puzzle description."""
    print("ğŸ“– Extracting examples from puzzle description...")
    examples = extract_examples_from_puzzle(puzzle, force_refresh=force_refresh)
    if examples:
        print(f"  ğŸ“‹ Extracted {len(examples)} examples:")
        for i, example in enumerate(examples, 1):
            print(f"    {i}. Input: {example['input'][:50]}{'...' if len(example['input']) > 50 else ''}")
            if example.get('expected_a'):
                print(f"       Expected Part A: {example['expected_a']}")
            if example.get('expected_b'):
                print(f"       Expected Part B: {example['expected_b']}")
    else:
        print("  â“ No examples extracted")


def run_day(year: int, day_number: int, parsed_args, suppress_solver_prints: bool = False):
    """Run a specific day with given arguments."""
    day_str = str(day_number).zfill(2)
    print(f"\nğŸ„ Advent of Code - Year {year} - Day {day_str}")
    
    # Save input if requested
    if parsed_args.save_input:
        puzzle = Puzzle(year, day_number)
        if not save_input_to_file(puzzle, verbose=True):
            return (False, False, False, (), 0)
        print("  âœ… Input saved successfully")
        return (False, False, False, (), 0)
    
    # Add day directory to Python path
    # Use absolute path to work from any directory, resolving symlinks
    script_dir = Path(os.path.realpath(__file__)).parent
    day_path = str(script_dir / f"events/year_{year}/day_{day_str}/")
    if day_path not in sys.path:
        sys.path.insert(0, day_path)
    
    try:
        module = __import__(f"day_{day_str}")
    except ImportError as e:
        print(f"âŒ Could not import day_{day_str}: {e}")
        return (False, False, False, (), 0)
    
    # Set up preprocessing function for solve_day to use
    if "preprocessing" in dir(module):
        preprocessing_func = module.preprocessing
    else:
        preprocessing_func = lambda x: x
    
    # Check if solver exists
    if 'solver' not in dir(module):
        print(f"âŒ No solver function defined in day_{day_str}")
        return (False, False, False, (), 0)
    
    puzzle = Puzzle(year, day_number)
    
    # Extract examples if requested
    if parsed_args.extract_examples or parsed_args.refresh_examples:
        display_extracted_examples(puzzle, force_refresh=parsed_args.refresh_examples)
    
    # Handle examples
    if parsed_args.examples or parsed_args.examples_verbose:
        print("ğŸ§ª Testing examples...")
        success = solve_examples(puzzle, parsed_args.examples_verbose)
        
        if success:
            print("âœ… All examples passed!")
        else:
            print("âŒ Some examples failed!")
            if not parsed_args.force:
                user_input = input("Continue with real input anyway? (y/N): ")
                if user_input.lower() not in ['y', 'yes']:
                    return (False, False, False, (), 0)
    
    # Run on real input
    print("ğŸš€ Running on real input...")
    timeout_display = (
        "disabled" if parsed_args.timeout == 0
        else f"{parsed_args.timeout} second{'s' if parsed_args.timeout != 1 else ''}"
    )
    print(f"  â±ï¸  Timeout set to {timeout_display}")
    
    # Display memory limit
    memory_display = (
        "unlimited" if parsed_args.memory_limit == 0
        else f"{parsed_args.memory_limit} MB"
    )
    print(f"  ğŸ’¾ Memory limit set to {memory_display}")
    
    result = solve_day(puzzle, use_local_input=not parsed_args.no_local,
                       preprocessing_func=preprocessing_func,
                       suppress_solver_prints=suppress_solver_prints,
                       timeout_seconds=parsed_args.timeout,
                       memory_limit_mb=parsed_args.memory_limit)
    # result is a 5-tuple: (all_correct, timeout_occurred, has_answers,
    # parts_solved_on_aoc, num_parts_returned)
    (all_correct, timeout_occurred, has_answers,
     parts_solved_on_aoc, num_parts_returned) = result
    return (all_correct, timeout_occurred, has_answers, parts_solved_on_aoc,
            num_parts_returned)


def display_scoreboard(year: int, days_to_run: list, day_results: dict):
    """Display a formatted scoreboard of all days."""
    total_days = len(days_to_run)
    successful_days = sum(
        1 for d in days_to_run
        if day_results.get(d, {}).get('success', False)
    )
    
    print(f"\n{'='*70}")
    print(f"ğŸ† Scoreboard - Advent of Code {year}")
    print(f"{'='*70}")
    print(f"{'Day':<6} {'Status':<20} {'Notes':<42}")
    print(f"{'-'*70}")
    
    # Check if we're running the full year (all 25 days)
    is_full_year = len(days_to_run) == 25 and all(d in days_to_run for d in range(1, 26))
    
    # Check if all days 1-24 are complete
    days_1_24_complete = all(
        day_results.get(d, {}).get('success', False) for d in range(1, 25)
    ) if is_full_year else False
    
    for day_num in days_to_run:
        day_str = str(day_num).zfill(2)
        result_info = day_results.get(day_num, {})
        
        success = result_info.get('success', False)
        notes = result_info.get('notes', '')
        
        # Special handling for day 25
        if day_num == 25 and success:
            # Day 25 is marked complete - check if part 2 is actually unlocked
            part2_unlocked = is_full_year and days_1_24_complete
            if not part2_unlocked:
                # Part 2 is not unlocked - show as incomplete
                status_emoji = "ğŸš§"
                status_text = "Incomplete"
                notes_display = "Part 2 locked (others incomplete)"
            else:
                # Part 2 is unlocked
                status_emoji = "âœ…"
                status_text = "Complete"
                notes_display = notes[:40]
        else:
            # Determine emoji and status text based on result for other days
            if success:
                status_emoji = "âœ…"
                status_text = "Complete"
                notes_display = notes[:40]
            elif "Timeout" in notes:
                status_emoji = "â±ï¸"
                status_text = " Timed out"
                notes_display = notes[:40]
            elif "Incomplete" in notes:
                status_emoji = "ğŸš§"
                status_text = "Incomplete"
                notes_display = notes[:40]
            else:
                status_emoji = "âŒ"
                status_text = "Failed"
                notes_display = notes[:40]
        
        print(f"{day_str:<6} {status_emoji} {status_text:<17} {notes_display:<42}")
    
    print(f"{'='*70}")
    # Count stars: 2 per complete day, 1 per incomplete day
    # Special case: Day 25's part 2 is auto-unlocked only if:
    # - We're running all 25 days AND
    # - All days 1-24 are complete AND  
    # - Day 25 part 1 is solved
    
    star_count = 0
    
    # Check if we're running the full year (all 25 days)
    is_full_year = len(days_to_run) == 25 and all(d in days_to_run for d in range(1, 26))
    
    # Check if all days 1-24 are complete
    days_1_24_complete = all(
        day_results.get(d, {}).get('success', False) for d in range(1, 25)
    ) if is_full_year else False
    
    for d in days_to_run:
        if d == 25:
            # Special handling for day 25
            day_25_info = day_results.get(25, {})
            day_25_success = day_25_info.get('success', False)
            day_25_incomplete = 'Incomplete' in day_25_info.get('notes', '')
            
            if day_25_success:
                # Day 25 complete: part 2 granted only if full year + all 1-24 complete
                star_count += 2 if (is_full_year and days_1_24_complete) else 1
            elif day_25_incomplete:
                # Day 25 incomplete: only 1 star for part 1
                star_count += 1
        else:
            # Regular days 1-24
            if day_results.get(d, {}).get('success', False):
                star_count += 2  # 2 stars for complete days
            elif 'Incomplete' in day_results.get(d, {}).get('notes', ''):
                star_count += 1  # 1 star for incomplete days
    
    percentage = 100 * successful_days // total_days if total_days > 0 else 0
    print(f"ğŸ“Š Summary: Total: {total_days}, Successful: {successful_days}/{total_days} "
          f"({percentage}%), Stars: {star_count} â­")
    print(f"{'='*70}\n")


# Global preprocessing function placeholder
pp = lambda x: x


if __name__ == '__main__':
    args = parse_arguments()
    
    # Determine which days to run
    days_to_run = []
    
    if args.day is not None:
        days_to_run = [args.day]
    elif args.days:
        try:
            days_to_run = parse_days_string(args.days)
        except ValueError as e:
            print(f"âŒ Invalid days format: {e}")
            sys.exit(1)
    else:
        # Run all days (1-25)
        days_to_run = list(range(1, 26))
    
    # Validate days
    invalid_days = [d for d in days_to_run if d < 1 or d > 25]
    if invalid_days:
        print(f"âŒ Invalid day numbers: {invalid_days} (must be 1-25)")
        sys.exit(1)
    
    print(f"ğŸ¯ Running {len(days_to_run)} day(s) for year {args.year}")
    if len(days_to_run) > 1:
        print(f"ğŸ“… Days: {', '.join(map(str, days_to_run))}")
    
    # Run each day
    success_count = 0
    suppress_prints = len(days_to_run) > 1
    day_results = {}  # Track results for scoreboard
    
    for day_num in days_to_run:
        try:
            result = run_day(args.year, day_num, args, suppress_solver_prints=suppress_prints)
            (all_correct, timeout_occurred, has_answers, parts_solved_on_aoc,
             num_parts_returned) = result
            
            if all_correct and not timeout_occurred:
                # Check if both parts were returned (day has 2 parts)
                if num_parts_returned < 2:
                    # Only one part returned when two are available - mark as incomplete
                    day_results[day_num] = {
                        'success': False,
                        'result': 'ğŸš§',
                        'notes': 'Incomplete'
                    }
                else:
                    success_count += 1
                    day_results[day_num] = {'success': True, 'result': 'âœ…', 'notes': 'Completed'}
            elif timeout_occurred:
                day_results[day_num] = {
                    'success': False,
                    'result': 'â±ï¸',
                    'notes': ' Timeout'
                }
            elif parts_solved_on_aoc == (1,) and not has_answers:
                # Only part 1 solved on AOC and no valid solver answers - show as incomplete
                day_results[day_num] = {'success': False, 'result': 'ğŸš§', 'notes': 'Incomplete'}
            elif has_answers and not all_correct:
                # Solver ran and returned answers, but not all are correct - Failed
                day_results[day_num] = {'success': False, 'result': 'âŒ', 'notes': 'Failed'}
            else:
                # Solver didn't run or had an error
                day_results[day_num] = {'success': False, 'result': 'âŒ', 'notes': 'Failed'}
        except KeyboardInterrupt:
            print("\nâ¹ï¸ Interrupted by user")
            break
        except Exception as exc:  # pylint: disable=broad-except
            exc_type = type(exc).__name__
            exc_msg = str(exc)[:100]  # Truncate long error messages
            print(f"âŒ Error running day {day_num} ({exc_type}): {exc_msg}")
            day_results[day_num] = {
                'success': False,
                'result': 'âŒ',
                'notes': f'Error: {exc_type}'
            }
    
    # Display scoreboard if running all or many days
    if len(days_to_run) > 1:
        display_scoreboard(args.year, days_to_run, day_results)
    
    print(f"ğŸ Completed {success_count}/{len(days_to_run)} days successfully")
