#!/usr/bin/env python3
"""
Scan AOC solution files and generate requirements.txt based on actual imports.
"""

import re
import os
from pathlib import Path
from collections import defaultdict

# Map import names to PyPI package names
PACKAGE_MAPPING = {
    'numpy': 'numpy>=1.21.0',
    'scipy': 'scipy>=1.7.0',
    'matplotlib': 'matplotlib>=3.5.0',
    'networkx': 'networkx>=2.8.0',
    'sympy': 'sympy>=1.9.0',
    'z3': 'z3-solver>=4.11.0',
    'parse': 'parse>=1.19.0',
    'regex': 'regex>=2023.0.0',
    'requests': 'requests>=2.28.0',
    'beautifulsoup4': 'beautifulsoup4>=4.11.0',
    'bs4': 'beautifulsoup4>=4.11.0',
    'pandas': 'pandas>=1.4.0',
    'pillow': 'Pillow>=9.0.0',
    'PIL': 'Pillow>=9.0.0',
    'opencv': 'opencv-python>=4.5.0',
    'cv2': 'opencv-python>=4.5.0',
    'more_itertools': 'more-itertools>=8.12.0',
    'pathfinding': 'pathfinding>=1.0.0',
    'aocd': 'advent-of-code-data>=2.0.1',
}

# Standard library modules (don't include in requirements)
STDLIB_MODULES = {
    'collections', 'itertools', 'functools', 'math', 're', 'sys', 'os', 
    'pathlib', 'random', 'operator', 'ast', 'typing', 'copy', 'dataclasses',
    'bisect', 'heapq', 'json', 'pickle', 'csv', 'datetime', 'time', 'argparse',
    'subprocess', 'threading', 'multiprocessing', 'queue', 'socket', 'http',
    'urllib', 'email', 'html', 'xml', 'base64', 'hashlib', 'hmac', 'secrets',
    'uuid', 'decimal', 'fractions', 'statistics', 'cmath', 'enum', 'io',
    'contextlib', 'abc', 'weakref', 'gc', 'inspect', 'dis', 'traceback',
    'warnings', 'logging', 'getpass', 'platform', 'shutil', 'tempfile',
    'glob', 'fnmatch', 'linecache', 'fileinput', 'struct', 'codecs'
}

def extract_imports_from_file(file_path):
    """Extract import statements from a Python file."""
    imports = set()
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Find import statements
        import_patterns = [
            r'^import\s+([^\s#]+)',  # import module
            r'^from\s+([^\s#.]+)',   # from module import ...
        ]
        
        for line in content.split('\n'):
            line = line.strip()
            for pattern in import_patterns:
                match = re.match(pattern, line)
                if match:
                    module = match.group(1)
                    # Handle cases like "import module as alias"
                    module = module.split(' as ')[0].split('.')[0]
                    imports.add(module)
    
    except (IOError, UnicodeDecodeError):
        pass  # Skip files that can't be read
    
    return imports

def scan_project_imports():
    """Scan all Python files in the project for imports."""
    project_root = Path(__file__).parent.parent
    all_imports = set()
    file_count = 0
    
    # Scan events directory
    events_dir = project_root / 'events'
    if events_dir.exists():
        for py_file in events_dir.rglob('*.py'):
            imports = extract_imports_from_file(py_file)
            all_imports.update(imports)
            file_count += 1
    
    # Scan main CLI scripts
    for script in ['aocp', 'aocr']:
        script_path = project_root / script
        if script_path.exists():
            imports = extract_imports_from_file(script_path)
            all_imports.update(imports)
            file_count += 1
    
    # Scan pythonfw
    pythonfw_dir = project_root / 'pythonfw'
    if pythonfw_dir.exists():
        for py_file in pythonfw_dir.rglob('*.py'):
            imports = extract_imports_from_file(py_file)
            all_imports.update(imports)
            file_count += 1
    
    print(f"üìä Scanned {file_count} Python files")
    return all_imports

def generate_requirements():
    """Generate requirements.txt based on scanned imports."""
    all_imports = scan_project_imports()
    
    # Filter out standard library modules and local imports
    external_packages = set()
    stdlib_found = set()
    unknown_imports = set()
    
    for imp in all_imports:
        if imp in STDLIB_MODULES or imp.startswith('events.') or imp.startswith('pythonfw.'):
            stdlib_found.add(imp)
        elif imp in PACKAGE_MAPPING:
            external_packages.add(PACKAGE_MAPPING[imp])
        else:
            unknown_imports.add(imp)
    
    # Always include core AOC packages
    core_packages = {
        'advent-of-code-data>=2.0.1',
        'requests>=2.28.0'
    }
    
    # Combine all packages
    all_packages = core_packages | external_packages
    
    # Generate requirements content
    content = """# Advent of Code Python Dependencies
# Auto-generated by scan_requirements.py

# Core AOC functionality
advent-of-code-data>=2.0.1
requests>=2.28.0
"""
    
    if external_packages - core_packages:
        content += "\n# Additional packages found in solutions\n"
        for package in sorted(external_packages - core_packages):
            content += f"{package}\n"
    
    # Report findings
    print(f"\nüì¶ Found packages:")
    for package in sorted(all_packages):
        print(f"  ‚úÖ {package}")
    
    if stdlib_found:
        print(f"\nüìö Standard library modules (not included):")
        for mod in sorted(list(stdlib_found)[:10]):  # Show first 10
            print(f"  üìñ {mod}")
        if len(stdlib_found) > 10:
            print(f"  ... and {len(stdlib_found) - 10} more")
    
    if unknown_imports:
        print(f"\n‚ùì Unknown imports (check manually):")
        for imp in sorted(unknown_imports):
            print(f"  ‚ö†Ô∏è  {imp}")
        content += f"\n# Unknown imports found (check manually):\n"
        for imp in sorted(unknown_imports):
            content += f"# {imp}\n"
    
    return content

def main():
    """Main function."""
    print("üîç Scanning Advent of Code project for Python dependencies...")
    
    # Generate new requirements
    new_content = generate_requirements()
    
    # Write to requirements.txt
    project_root = Path(__file__).parent.parent
    req_file = project_root / 'requirements.txt'
    
    with open(req_file, 'w', encoding='utf-8') as f:
        f.write(new_content)
    
    print(f"\n‚úÖ Updated {req_file}")
    print("\nüí° Review the requirements.txt file and install with:")
    print("   python3 -m pip install -r requirements.txt")

if __name__ == '__main__':
    main()